// Code generated by counterfeiter. DO NOT EDIT.
package fake_keys

import (
	"sync"

	"code.cloudfoundry.org/diego-ssh/keys"
	"golang.org/x/crypto/ssh"
)

type FakeKeyPair struct {
	AuthorizedKeyStub        func() string
	authorizedKeyMutex       sync.RWMutex
	authorizedKeyArgsForCall []struct {
	}
	authorizedKeyReturns struct {
		result1 string
	}
	authorizedKeyReturnsOnCall map[int]struct {
		result1 string
	}
	FingerprintStub        func() string
	fingerprintMutex       sync.RWMutex
	fingerprintArgsForCall []struct {
	}
	fingerprintReturns struct {
		result1 string
	}
	fingerprintReturnsOnCall map[int]struct {
		result1 string
	}
	PEMEncodedPrivateKeyStub        func() string
	pEMEncodedPrivateKeyMutex       sync.RWMutex
	pEMEncodedPrivateKeyArgsForCall []struct {
	}
	pEMEncodedPrivateKeyReturns struct {
		result1 string
	}
	pEMEncodedPrivateKeyReturnsOnCall map[int]struct {
		result1 string
	}
	PrivateKeyStub        func() ssh.Signer
	privateKeyMutex       sync.RWMutex
	privateKeyArgsForCall []struct {
	}
	privateKeyReturns struct {
		result1 ssh.Signer
	}
	privateKeyReturnsOnCall map[int]struct {
		result1 ssh.Signer
	}
	PublicKeyStub        func() ssh.PublicKey
	publicKeyMutex       sync.RWMutex
	publicKeyArgsForCall []struct {
	}
	publicKeyReturns struct {
		result1 ssh.PublicKey
	}
	publicKeyReturnsOnCall map[int]struct {
		result1 ssh.PublicKey
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKeyPair) AuthorizedKey() string {
	fake.authorizedKeyMutex.Lock()
	ret, specificReturn := fake.authorizedKeyReturnsOnCall[len(fake.authorizedKeyArgsForCall)]
	fake.authorizedKeyArgsForCall = append(fake.authorizedKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("AuthorizedKey", []interface{}{})
	authorizedKeyStubCopy := fake.AuthorizedKeyStub
	fake.authorizedKeyMutex.Unlock()
	if authorizedKeyStubCopy != nil {
		return authorizedKeyStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authorizedKeyReturns
	return fakeReturns.result1
}

func (fake *FakeKeyPair) AuthorizedKeyCallCount() int {
	fake.authorizedKeyMutex.RLock()
	defer fake.authorizedKeyMutex.RUnlock()
	return len(fake.authorizedKeyArgsForCall)
}

func (fake *FakeKeyPair) AuthorizedKeyCalls(stub func() string) {
	fake.authorizedKeyMutex.Lock()
	defer fake.authorizedKeyMutex.Unlock()
	fake.AuthorizedKeyStub = stub
}

func (fake *FakeKeyPair) AuthorizedKeyReturns(result1 string) {
	fake.authorizedKeyMutex.Lock()
	defer fake.authorizedKeyMutex.Unlock()
	fake.AuthorizedKeyStub = nil
	fake.authorizedKeyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) AuthorizedKeyReturnsOnCall(i int, result1 string) {
	fake.authorizedKeyMutex.Lock()
	defer fake.authorizedKeyMutex.Unlock()
	fake.AuthorizedKeyStub = nil
	if fake.authorizedKeyReturnsOnCall == nil {
		fake.authorizedKeyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.authorizedKeyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) Fingerprint() string {
	fake.fingerprintMutex.Lock()
	ret, specificReturn := fake.fingerprintReturnsOnCall[len(fake.fingerprintArgsForCall)]
	fake.fingerprintArgsForCall = append(fake.fingerprintArgsForCall, struct {
	}{})
	fake.recordInvocation("Fingerprint", []interface{}{})
	fingerprintStubCopy := fake.FingerprintStub
	fake.fingerprintMutex.Unlock()
	if fingerprintStubCopy != nil {
		return fingerprintStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fingerprintReturns
	return fakeReturns.result1
}

func (fake *FakeKeyPair) FingerprintCallCount() int {
	fake.fingerprintMutex.RLock()
	defer fake.fingerprintMutex.RUnlock()
	return len(fake.fingerprintArgsForCall)
}

func (fake *FakeKeyPair) FingerprintCalls(stub func() string) {
	fake.fingerprintMutex.Lock()
	defer fake.fingerprintMutex.Unlock()
	fake.FingerprintStub = stub
}

func (fake *FakeKeyPair) FingerprintReturns(result1 string) {
	fake.fingerprintMutex.Lock()
	defer fake.fingerprintMutex.Unlock()
	fake.FingerprintStub = nil
	fake.fingerprintReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) FingerprintReturnsOnCall(i int, result1 string) {
	fake.fingerprintMutex.Lock()
	defer fake.fingerprintMutex.Unlock()
	fake.FingerprintStub = nil
	if fake.fingerprintReturnsOnCall == nil {
		fake.fingerprintReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.fingerprintReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) PEMEncodedPrivateKey() string {
	fake.pEMEncodedPrivateKeyMutex.Lock()
	ret, specificReturn := fake.pEMEncodedPrivateKeyReturnsOnCall[len(fake.pEMEncodedPrivateKeyArgsForCall)]
	fake.pEMEncodedPrivateKeyArgsForCall = append(fake.pEMEncodedPrivateKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("PEMEncodedPrivateKey", []interface{}{})
	pEMEncodedPrivateKeyStubCopy := fake.PEMEncodedPrivateKeyStub
	fake.pEMEncodedPrivateKeyMutex.Unlock()
	if pEMEncodedPrivateKeyStubCopy != nil {
		return pEMEncodedPrivateKeyStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pEMEncodedPrivateKeyReturns
	return fakeReturns.result1
}

func (fake *FakeKeyPair) PEMEncodedPrivateKeyCallCount() int {
	fake.pEMEncodedPrivateKeyMutex.RLock()
	defer fake.pEMEncodedPrivateKeyMutex.RUnlock()
	return len(fake.pEMEncodedPrivateKeyArgsForCall)
}

func (fake *FakeKeyPair) PEMEncodedPrivateKeyCalls(stub func() string) {
	fake.pEMEncodedPrivateKeyMutex.Lock()
	defer fake.pEMEncodedPrivateKeyMutex.Unlock()
	fake.PEMEncodedPrivateKeyStub = stub
}

func (fake *FakeKeyPair) PEMEncodedPrivateKeyReturns(result1 string) {
	fake.pEMEncodedPrivateKeyMutex.Lock()
	defer fake.pEMEncodedPrivateKeyMutex.Unlock()
	fake.PEMEncodedPrivateKeyStub = nil
	fake.pEMEncodedPrivateKeyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) PEMEncodedPrivateKeyReturnsOnCall(i int, result1 string) {
	fake.pEMEncodedPrivateKeyMutex.Lock()
	defer fake.pEMEncodedPrivateKeyMutex.Unlock()
	fake.PEMEncodedPrivateKeyStub = nil
	if fake.pEMEncodedPrivateKeyReturnsOnCall == nil {
		fake.pEMEncodedPrivateKeyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pEMEncodedPrivateKeyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKeyPair) PrivateKey() ssh.Signer {
	fake.privateKeyMutex.Lock()
	ret, specificReturn := fake.privateKeyReturnsOnCall[len(fake.privateKeyArgsForCall)]
	fake.privateKeyArgsForCall = append(fake.privateKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("PrivateKey", []interface{}{})
	privateKeyStubCopy := fake.PrivateKeyStub
	fake.privateKeyMutex.Unlock()
	if privateKeyStubCopy != nil {
		return privateKeyStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.privateKeyReturns
	return fakeReturns.result1
}

func (fake *FakeKeyPair) PrivateKeyCallCount() int {
	fake.privateKeyMutex.RLock()
	defer fake.privateKeyMutex.RUnlock()
	return len(fake.privateKeyArgsForCall)
}

func (fake *FakeKeyPair) PrivateKeyCalls(stub func() ssh.Signer) {
	fake.privateKeyMutex.Lock()
	defer fake.privateKeyMutex.Unlock()
	fake.PrivateKeyStub = stub
}

func (fake *FakeKeyPair) PrivateKeyReturns(result1 ssh.Signer) {
	fake.privateKeyMutex.Lock()
	defer fake.privateKeyMutex.Unlock()
	fake.PrivateKeyStub = nil
	fake.privateKeyReturns = struct {
		result1 ssh.Signer
	}{result1}
}

func (fake *FakeKeyPair) PrivateKeyReturnsOnCall(i int, result1 ssh.Signer) {
	fake.privateKeyMutex.Lock()
	defer fake.privateKeyMutex.Unlock()
	fake.PrivateKeyStub = nil
	if fake.privateKeyReturnsOnCall == nil {
		fake.privateKeyReturnsOnCall = make(map[int]struct {
			result1 ssh.Signer
		})
	}
	fake.privateKeyReturnsOnCall[i] = struct {
		result1 ssh.Signer
	}{result1}
}

func (fake *FakeKeyPair) PublicKey() ssh.PublicKey {
	fake.publicKeyMutex.Lock()
	ret, specificReturn := fake.publicKeyReturnsOnCall[len(fake.publicKeyArgsForCall)]
	fake.publicKeyArgsForCall = append(fake.publicKeyArgsForCall, struct {
	}{})
	fake.recordInvocation("PublicKey", []interface{}{})
	publicKeyStubCopy := fake.PublicKeyStub
	fake.publicKeyMutex.Unlock()
	if publicKeyStubCopy != nil {
		return publicKeyStubCopy()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publicKeyReturns
	return fakeReturns.result1
}

func (fake *FakeKeyPair) PublicKeyCallCount() int {
	fake.publicKeyMutex.RLock()
	defer fake.publicKeyMutex.RUnlock()
	return len(fake.publicKeyArgsForCall)
}

func (fake *FakeKeyPair) PublicKeyCalls(stub func() ssh.PublicKey) {
	fake.publicKeyMutex.Lock()
	defer fake.publicKeyMutex.Unlock()
	fake.PublicKeyStub = stub
}

func (fake *FakeKeyPair) PublicKeyReturns(result1 ssh.PublicKey) {
	fake.publicKeyMutex.Lock()
	defer fake.publicKeyMutex.Unlock()
	fake.PublicKeyStub = nil
	fake.publicKeyReturns = struct {
		result1 ssh.PublicKey
	}{result1}
}

func (fake *FakeKeyPair) PublicKeyReturnsOnCall(i int, result1 ssh.PublicKey) {
	fake.publicKeyMutex.Lock()
	defer fake.publicKeyMutex.Unlock()
	fake.PublicKeyStub = nil
	if fake.publicKeyReturnsOnCall == nil {
		fake.publicKeyReturnsOnCall = make(map[int]struct {
			result1 ssh.PublicKey
		})
	}
	fake.publicKeyReturnsOnCall[i] = struct {
		result1 ssh.PublicKey
	}{result1}
}

func (fake *FakeKeyPair) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authorizedKeyMutex.RLock()
	defer fake.authorizedKeyMutex.RUnlock()
	fake.fingerprintMutex.RLock()
	defer fake.fingerprintMutex.RUnlock()
	fake.pEMEncodedPrivateKeyMutex.RLock()
	defer fake.pEMEncodedPrivateKeyMutex.RUnlock()
	fake.privateKeyMutex.RLock()
	defer fake.privateKeyMutex.RUnlock()
	fake.publicKeyMutex.RLock()
	defer fake.publicKeyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKeyPair) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ keys.KeyPair = new(FakeKeyPair)
